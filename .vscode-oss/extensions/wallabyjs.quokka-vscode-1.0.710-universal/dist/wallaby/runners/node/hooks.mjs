import{appendFileSync,existsSync,readdirSync,unlinkSync}from"node:fs";import{join,dirname}from"node:path";import{}from"node:fs";import{pathToFileURL}from"url";import*as module from"node:module";import{MessageChannel}from"node:worker_threads";import{homedir}from"node:os";function findFileUpward(e){const o=homedir();try{let r=process.cwd();for(;r;){const n=join(r,e);if(existsSync(n))return n;const t=dirname(r);if(t===r||t===o)break;r=t}return null}catch(e){return null}}const logFileName=join(homedir(),".wallaby","hooks.log");function warn(e){try{appendFileSync(logFileName,`WARN ${(new Date).toISOString()} ${e}\n`)}catch(e){}}function error(e){try{appendFileSync(logFileName,`ERROR ${(new Date).toISOString()} ${e}\n`)}catch(e){}}existsSync(logFileName)&&unlinkSync(logFileName);const pnpLoaderFilename=findFileUpward(".pnp.loader.mjs"),pnpLoaderExists=!!pnpLoaderFilename;let pnpLoader,customConditions;async function getPnpLoader(){return pnpLoader||(pnpLoader=await import(pnpLoaderFilename),pnpLoader)}function convertToPosix(e){return"win32"===process.platform?e.replace(/\\/g,"/"):e}export function setExternalLoad(e){global.$_$_externalLoad=e}export function setExternalResolve(e){global.$_$_externalResolve=e}export function findMatchingFiles(e,o,r,n){const t=[];for(const r of readdirSync(e))r.match(o)&&t.push(convertToPosix(join(e,r)));if(r&&0===t.length)throw new Error(`File '${o}' is not found in '${e}'`);if(n&&t.length>1)throw new Error(`More than one file '${o}' were found in '${e}'`);return t}export function patchFile(e,o){const r=pathToFileURL(e).toString();global.$_$esmHooksPort?global.$_$esmHooksPort.postMessage({type:"patch",url:r,patches:o}):addPatch(r,o)}export function getErrorsAndWarnings(){const[e]=process.versions.node.split(".").map((e=>parseInt(e,10)));return e>=22?{warnings:global.$_$_esm_warnings||[],errors:global.$_$_esm_errors||[]}:global.$_$esmHooksPort?new Promise(((e,o)=>{const r=o=>{const{type:n,warnings:t,errors:a}=o.data;if("errorsAndWarnings"===n)e({warnings:t,errors:a}),global.$_$esmHooksPort.removeEventListener("message",r)};global.$_$esmHooksPort.addEventListener("message",r),global.$_$esmHooksPort.postMessage({type:"getWarnings"})})):{warnings:global.$_$_esm_warnings||[],errors:global.$_$_esm_errors||[]}}export async function resolve(e,o,r){if(customConditions&&(o.conditions=[...customConditions,...o.conditions||[]]),global.$_$_externalResolve)try{const n=await global.$_$_externalResolve(e,o,r);if(n)return n}catch(e){}if(!pnpLoaderExists)return await r(e,o,r);try{return await r(e,o,r)}catch(n){const t=(await getPnpLoader()).resolve;return await t(e,o,r)}}export function applyReplacements(e,o,r){let n="";return o.reduce(((o,r)=>(r.forEach(((t,a)=>{if(!n&&-1===o.indexOf(t.from)&&!t.optional)if(t.key){if(!r.find(((e,r)=>r!==a&&e.key===t.key&&-1!==o.indexOf(e.from)))){const o=`Wallaby is not compatible with current version of Vitest.\nCould not find ${t.key} in entry point for file ${e.toString()}.`;t.warn?(global.$_$_esm_warnings.push(o),warn(o)):(global.$_$_esm_errors.push(o),error(o),n=o)}}else{const o=`Wallaby is not compatible with current version of Vitest.\nCould not find ${t.from} in entry point for file ${e.toString()}.`;t.warn?(global.$_$_esm_warnings.push(o),warn(o)):(global.$_$_esm_errors.push(o),error(o),n=o)}})),n?`throw new Error(${JSON.stringify(n)});`:r.reduce(((e,o)=>e.replace(o.from,o.to)),o))),r)}async function loadAndPatch(e,o,r,n){const t=await n(e,o,r);return global.$_$_esm_patches&&global.$_$_esm_patches[e]&&t.source&&(t.source=applyReplacements(e,global.$_$_esm_patches[e],t.source.toString())),t}export async function load(e,o,r){if(global.$_$_externalLoad)try{return await loadAndPatch(e,o,r,global.$_$_externalLoad)}catch(e){}if(!pnpLoaderExists)return await loadAndPatch(e,o,r,r);try{const n=await loadAndPatch(e,o,r,r);if("builtin"!==n.format&&!n.source){const n=(await getPnpLoader()).load;return await loadAndPatch(e,o,r,n)}return n}catch(n){try{const n=(await getPnpLoader()).load;return await loadAndPatch(e,o,r,n)}catch(e){throw n}}}function addPatch(e,o){global.$_$_esm_patches=global.$_$_esm_patches||{},global.$_$_esm_warnings=[],global.$_$_esm_errors=[],global.$_$_esm_patches[e]?global.$_$_esm_patches[e].push(o):global.$_$_esm_patches[e]=[o]}export function globalPreload(e){const o=[];for(let e=0;e<process.execArgv.length;e++){const r=process.execArgv[e];("--conditions"===r||"-C"===r)&&e+1<process.execArgv.length&&o.push(process.execArgv[e+1])}customConditions=o.length?o:void 0;const[r,n]=process.versions.node.split(".").map((e=>parseInt(e,10)));if(r<18||18===r&&n<19)return;if(!e||!e.port)throw new Error("Unexpected globalPreload argument value");const t=e.port;return t.onmessage=e=>{const{type:o,url:r,patches:n}=e.data;switch(o){case"patch":addPatch(r,n);break;case"getWarnings":t.postMessage({type:"errorsAndWarnings",warnings:global.$_$_esm_warnings,errors:global.$_$_esm_errors})}},"    global.$_$esmHooksPort = port;\n  "}export async function initialize(e){globalPreload(e)}export async function registerHook(){const[e,o]=process.versions.node.split(".").map((e=>parseInt(e,10)));if(e<18||18===e&&o<19||20===e&&o<6)return;const{port1:r,port2:n}=new MessageChannel;global.$_$esmHooksPort=r,await module.register(import.meta.url,{parentURL:import.meta.url,data:{number:1,port:n},transferList:[n]})}